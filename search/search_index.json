{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"get-started/","title":"Get Started","text":"<p>Componego Framework seamlessly integrates components, dependency injection, configuration, and error handling, providing a robust foundation for building modular, scalable, and maintainable software systems.</p> <p>The framework embraces a component-based architecture. These components encapsulate specific functionalities and seamlessly integrate to construct more complex applications. By promoting code reusability and maintainability, the framework allows developers to work on independent units.</p> <p>Main features of the framework:</p> <ol> <li>A well-organized application initialization process with a minimal main function.</li> <li>Simple and powerful components.</li> <li>Flexible dependency injection that doesn't require code generation.</li> <li>The core of the framework does not depend on third-party packages.</li> <li>Easily integrates with existing code and third-party packages.</li> <li>No impact on the business logic of your application. You can write and organize it just as you did before.</li> <li>Any entity of the framework can be replaced without changing previously written code.</li> <li>Comprehensive and clear documentation for developers.</li> </ol> <p>The framework does not provide a database connection, web server, queue, and other features. Instead, we offer the ability to conveniently integrate these components for later reuse in your projects. You can use any packages you prefer; there are no limits. Any existing Golang package can be easily wrapped in the framework's components.</p> <p>Note</p> <p>The documentation provides a brief description of the main functions of the framework. You may find some aspects complicated, but we include links for each part described in another section.</p> <p>You need to create an application or component using this framework to fully understand it. Don't hesitate to open the source code. There, you will find many interesting functions that are not described in the documentation.</p> <p>How to create an application?</p> <p>How to run an application?</p> <p>How to create a component?</p> <p>How to use dependency injections?</p> <p>How to use configuration?</p> <p>How to handle errors?</p> <p>How to create mocks?</p> <p>How to create tests?</p>"},{"location":"contribution/guide/","title":"Contribution Guide","text":"<p>This section is intended for users who wish to contribute to the framework.</p> <p>Contributions can include new features, changes to existing features, tests, documentation (such as developer guides, examples, or specifications), bug fixes, optimizations, or valuable suggestions.</p> <p>Please follow the main rules for making changes to the codebase:</p> <ol> <li>We use pre-commit to run a custom hook when code is committed. Please install it.</li> <li>After making changes, please run the tests using our utility:        <pre><code>% make tests\n</code></pre></li> <li>Please do not include third-party packages in the framework's codebase.</li> <li>Before creating a pull request or merging to our repository, please perform a git rebase.</li> <li>The language of communication is English. All commits, comments, tasks, and questions must be written in English.</li> </ol> <p>You can use the following commands to quickly create a framework contributor environment: <pre><code>curl -sSL https://raw.githubusercontent.com/componego/componego/master/tools/create-contributor-env.sh | sh\n</code></pre> or <pre><code>wget -O - https://raw.githubusercontent.com/componego/componego/master/tools/create-contributor-env.sh | sh\n</code></pre></p> <p>If you like our framework, you can share it with your friends, which will help the project develop further.</p> <p>Twitter | X LinkedIn Facebook</p> <p> Thank you.</p>"},{"location":"impl/application/","title":"Application","text":""},{"location":"impl/application/#basic-application","title":"Basic Application","text":"<p>The application is a struct with a set of methods that describe the elements of this application.</p> <p>Let's create your first application and launch it:     <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/application\"\n    \"github.com/componego/componego/impl/runner\"\n)\n\ntype Application struct {\n}\n\nfunc (a *Application) ApplicationName() string {\n    return \"Hello World App\"\n}\n\nfunc (a *Application) ApplicationAction(env componego.Environment, options any) (int, error) {\n    _, err := fmt.Fprintln(env.ApplicationIO().OutputWriter(), \"Hello World!\")\n    return application.ExitWrapper(err)\n}\n\nfunc main() {\n    runner.RunAndExit(&amp;Application{}, componego.ProductionMode)\n}\n</code></pre> Save this code to a file and run it without any arguments.</p> <p>Don't forget to initialize go mod and download all dependencies.     <pre><code>% go run main.go\nHello world!\n</code></pre></p> <p>The source code for this example application is available here.</p> <p>Details about the runner are provided on the next page.</p>"},{"location":"impl/application/#mandatory-methods","title":"Mandatory methods","text":""},{"location":"impl/application/#applicationname","title":"ApplicationName","text":"<p>The function returns the application name:     <pre><code>func (a *Application) ApplicationName() string {\n    return \"The Best Application\"\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/application/#applicationaction","title":"ApplicationAction","text":"<p>The function describes the main action of the current application:     <pre><code>func (a *Application) ApplicationAction(env componego.Environment, options any) (int, error) {\n    // ...\n    return componego.SuccessExitCode, nil\n}\n\n// ...\n</code></pre> In this function, you can implement the business logic for your application.</p> <p>The first argument of this method is an environment, with which you can access any function of the framework.</p> <p>The second argument is additional options that you can pass to your application using the driver.</p>"},{"location":"impl/application/#optional-methods","title":"Optional methods","text":""},{"location":"impl/application/#applicationcomponents","title":"ApplicationComponents","text":"<p>The application may depend on components:     <pre><code>func (a *Application) ApplicationComponents() ([]componego.Component, error) {\n    return []componego.Component{ /* ... */ }, nil\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/application/#applicationdependencies","title":"ApplicationDependencies","text":"<p>It can provide any dependencies:     <pre><code>func (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{ /* ... */ }, nil\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/application/#applicationconfiginit","title":"ApplicationConfigInit","text":"<p>The application can read any configuration:     <pre><code>func (a *Application) ApplicationConfigInit(appMode componego.ApplicationMode, options any) (map[string]any, error) {\n    return map[string]any{\n        \"config.key\": \"config.value\",\n    }, nil\n}\n\n// ...\n</code></pre> You can return different configuration depending on the mode the application is running in.</p> <p>The second argument of the method is additional options. These are the same options as in the application action.</p>"},{"location":"impl/application/#applicationerrorhandler","title":"ApplicationErrorHandler","text":"<p>By default, there is also a method that handles all your errors that were not handled previously:     <pre><code>func (a *Application) ApplicationErrorHandler(err error, appIO componego.ApplicationIO, appMode componego.ApplicationMode) error {\n    if errors.Is(err, MyError) {\n        // ...\n        err = nil\n    } else {\n        // ...\n    }\n    return err\n}\n</code></pre> This method also intercepts global panic in the application.</p> <p>Unhandled errors returned by this method will be received and processed by the runner at the core level.</p> <p>You can also catch errors at the component level.</p> <p>Note</p> <p>For improved clarity and compile-time validation, you can add the following code: <pre><code>var (\n    _ componego.Application             = (*Application)(nil)\n    _ componego.ApplicationComponents   = (*Application)(nil)\n    _ componego.ApplicationDependencies = (*Application)(nil)\n    _ componego.ApplicationConfigInit   = (*Application)(nil)\n    _ componego.ApplicationErrorHandler = (*Application)(nil)\n)\n</code></pre> The names of the interfaces correspond to the logic they implement.</p> <p>It is recommended to always add such validation to easily find and fix problems in the code if changes are made to interface methods in future versions of the framework.</p> <p>Note</p> <p>You can also add your own methods and implement custom logic, as the application is a struct that implements interfaces.</p> <p>Note</p> <p>Pay special attention to the order in which methods are called. This attention will help you understand the application initialization process.</p>"},{"location":"impl/application/#application-factory","title":"Application Factory","text":"<p>There is also a short code for creating the application. However, we do not recommend using this method:     <pre><code>package main\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/application\"\n    \"github.com/componego/componego/impl/runner\"\n)\n\nfunc main() {\n    factory := application.NewFactory(\"Application Name\")\n    factory.SetApplicationDependencies(func() ([]componego.Dependency, error) {\n        return []componego.Dependency{ /* ... */ }, nil\n    })\n    factory.SetApplicationAction(func(env componego.Environment, options any) (int, error) {\n        // ...\n        return componego.SuccessExitCode, nil\n    })\n    // ... other methods.\n    runner.RunAndExit(factory.Build(), componego.ProductionMode)\n}\n</code></pre> The factory has various Set* methods that correspond to the methods described above.</p>"},{"location":"impl/application/#application-skeleton","title":"Application Skeleton","text":"<p>You can quickly create an application skeleton using the following ways:     <pre><code>curl -sSL https://raw.githubusercontent.com/componego/componego/master/tools/create-basic-app.sh | sh\n</code></pre> or     <pre><code>wget -O - https://raw.githubusercontent.com/componego/componego/master/tools/create-basic-app.sh | sh\n</code></pre></p> <p>On Windows, you can run the commands above using Git Bash.</p> <p>These commands will create componego-basic-app folder with the most basic version of the application, based on which you can begin development.</p> <p>An example of a full-fledged application using our framework can be found here.</p> <p>To learn more, visit other documentation pages.</p>"},{"location":"impl/component/","title":"Application Components","text":""},{"location":"impl/component/#basic-component","title":"Basic Component","text":"<p>A component is a modular, reusable piece of code that performs a specific function in a larger application. Components are designed as independent, self-contained units that can be easily integrated into an application.</p> <p>Components are not microservices. They are folders that contain different functionalities. We use a struct with a set of methods to describe the functionalities a component depends on and the functionalities it provides.</p> <p>The basic component looks like this:     <pre><code>package component\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Component struct {\n}\n\nfunc NewComponent() *Component {\n    return &amp;Component{}\n}\n\nfunc (c *Component) ComponentIdentifier() string {\n    return \"company-name:component-name\"\n}\n\nfunc (c *Component) ComponentVersion() string {\n    return \"0.0.1\"\n}\n\nvar (\n    _ componego.Component = (*Component)(nil)\n)\n</code></pre> This component does not perform any actions because it lacks the methods that provide various functionalities.</p> <p>Pay attention to methods that the component can provide in the documentation below in the next section. Look at the example below to see how you can add a component to your application:     <pre><code>package application\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationComponents() ([]componego.Component, error) {\n    return []componego.Component{\n        NewComponent(),\n    }, nil\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationComponents = (*Application)(nil)\n)\n</code></pre></p>"},{"location":"impl/component/#mandatory-methods","title":"Mandatory methods","text":""},{"location":"impl/component/#componentidentifier","title":"ComponentIdentifier","text":"<p>This function returns the component ID:     <pre><code>func (c *Component) ComponentIdentifier() string {\n    return \"company-name:component-name\"\n}\n\n// ...\n</code></pre> If the identifier in multiple components is the same, the last one will be used. You can use it for overwriting components.</p>"},{"location":"impl/component/#componentversion","title":"ComponentVersion","text":"<p>This function returns the version of the component:     <pre><code>func (c *Component) ComponentVersion() string {\n    return \"0.0.1\"\n}\n\n// ...\n</code></pre> The version must match the SemVer format.</p> <p>Note</p> <p>It is always recommended to increment the component version when making changes to the component.</p>"},{"location":"impl/component/#optional-methods","title":"Optional methods","text":"<p>Note</p> <p>Any component struct is similar to the application struct. However, there are slight differences in their methods.</p>"},{"location":"impl/component/#componentcomponents","title":"ComponentComponents","text":"<p>Any component may depend on other components:     <pre><code>func (a *Component) ComponentComponents() ([]componego.Component, error) {\n    return []componego.Component{ /* ... */ }, nil\n}\n\n// ...\n</code></pre></p> <p>Note</p> <p>The order in which components are loaded depends on their dependencies.</p> <p>This also affects the component overwriting rules: components listed last will overwrite those listed first if they share the same identifier.</p>"},{"location":"impl/component/#componentdependencies","title":"ComponentDependencies","text":"<p>Like an application, it can provide dependencies:     <pre><code>func (a *Component) ComponentDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{ /* ... */ }, nil\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/component/#componentinit","title":"ComponentInit","text":"<p>This function is called in the order of dependencies between components. You can add custom logic to this method:     <pre><code>func (a *Component) ComponentInit(env componego.Environment) error {\n    // ...\n    return nil\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/component/#componentstop","title":"ComponentStop","text":"<p>This method is called when the component stops. You can handle the previous error by returning either a new or the original error:     <pre><code>func (a *Component) ComponentStop(env componego.Environment, prevErr error)  error {\n    // ...\n    return prevErr\n}\n\n// ...\n</code></pre></p> <p>Note</p> <p>For greater clarity and compile-time validation, you can add the following code: <pre><code>var (\n    _ componego.Component             = (*Component)(nil)\n    _ componego.ComponentComponents   = (*Component)(nil)\n    _ componego.ComponentDependencies = (*Component)(nil)\n    _ componego.ComponentInit         = (*Component)(nil)\n    _ componego.ComponentStop         = (*Component)(nil)\n)\n</code></pre> These names correspond to the logic they implement. It is always recommended to add such validation to easily find and fix problems in the code, especially if changes are made to interface methods in future versions of the framework.</p>"},{"location":"impl/component/#initialization-rewriting","title":"Initialization &amp; Rewriting","text":"<p>Pay attention to the following example:     <pre><code>package application\n\nimport (\n    \"github.com/componego/componego\"\n\n    \"secret.com/project-x/components/database1\"\n    \"secret.com/project-x/components/database2\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationComponents() ([]componego.Component, error) {\n    return []componego.Component{\n        database1.NewComponent(),\n        // ...\n        database2.NewComponent(),\n    }, nil\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationComponents = (*Application)(nil)\n)\n</code></pre> If both connected components share the same identifier, only the last one will be used.</p> <p>Note</p> <p>You can get a list of active components through the environment. <pre><code>activeAndSortedComponents := env.Components()\nfor _, component := range activeAndSortedComponents {\n    _, _ = fmt.Fprintf(\n        env.ApplicationIO().OutputWriter(),\n        \"identifier: %s, version: %s, struct type: %T\\n\",\n        component.ComponentIdentifier(), component.ComponentVersion(), component,\n    )\n}\n</code></pre> We print the unique ID in the loop so you can see which components are currently in use.</p> <p>It also supports overriding components that have multiple levels of nesting. You can observe how it works in the project code.</p>"},{"location":"impl/component/#component-factory","title":"Component Factory","text":"<p>There is also a brief code snippet for creating the component. This is the same thing as for an application.     <pre><code>package component\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/component\"\n)\n\nfunc NewComponent() componego.Component {\n    factory := component.NewFactory(\"identifier\", \"0.0.1\")\n    factory.SetComponentInit(func(env componego.Environment) error {\n        // ...\n        return nil\n    })\n    // ... other methods.\n    return factory.Build()\n}\n</code></pre></p>"},{"location":"impl/config/","title":"Configuration","text":""},{"location":"impl/config/#basic-information","title":"Basic Information","text":"<p>Configuration is an important part of every application.</p> <p>The framework provides a single point for reading the configuration through a special method that you can add to an application struct:     <pre><code>package application\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationConfigInit(appMode componego.ApplicationMode, options any) (map[string]any, error) {\n    return map[string]any{\n        \"config.key1\": \"config.value1\",\n        \"config.key2\": \"config.value2\",\n        // ...\n    }, nil\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationConfigInit = (*Application)(nil)\n)\n</code></pre> This method returns a map containing the configuration keys and values. You can also return an error if there was an issue reading the configuration.</p> <p>This method is called only once and should return the configuration for the application and all components within that application.</p>"},{"location":"impl/config/#configuration-reader","title":"Configuration Reader","text":"<p>You can read the configuration in various ways.</p> <p>For example, you can use third-party libraries to obtain the configuration. However, your function or library must return a variable of the type map[string]any:     <pre><code>package application\n\nimport (\n    \"fmt\"\n\n    \"github.com/componego/componego\"\n    \"github.com/spf13/viper\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationConfigInit(appMode componego.ApplicationMode, options any) (map[string]any, error) {\n    switch appMode {\n    case componego.ProductionMode:\n        return ConfigReader(\"./config/production.config.json\")\n    // ...\n    default:\n        return nil, fmt.Errorf(\"not supported application mode: %d\", appMode)\n    }\n}\n\nfunc ConfigReader(filename string) (map[string]any, error) {\n    // This function should be placed in a separate package.\n    v := viper.New()\n    v.SetConfigFile(filename)\n    if err := v.ReadInConfig(); err != nil {\n        return nil, err\n    }\n    return v.AllSettings(), nil\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationConfigInit = (*Application)(nil)\n)\n</code></pre></p> <p>You can also perform post-processing of values after reading the configuration:     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego/impl/environment/managers/config\"\n    \"github.com/spf13/viper\"\n)\n\nfunc ConfigReader(filename string) (map[string]any, error) {\n    // This function should be placed in a separate package.\n    v := viper.NewWithOptions()\n    // ...\n    settings := v.AllSettings()\n    return settings, config.ProcessVariables(settings)\n}\n</code></pre></p> <p>This function converts the following values:     <pre><code>{\n    \"server\": {\n        \"addr\": \":${ENV:APP_PORT}\"\n    }\n}\n</code></pre> into:     <pre><code>{\n    \"server\": {\n        \"addr\": \":1234\"\n    }\n}\n</code></pre> You can also use the default value after a pipe:     <pre><code>{\n    \"server\": {\n        \"addr\": \":${ENV:APP_PORT|1234}\"\n    }\n}\n</code></pre></p> <p>We have described the map that ApplicationConfigInit returns. The next section describes how to get this value in your application or component.</p>"},{"location":"impl/config/#configuration-getter","title":"Configuration Getter","text":"<p>Any configuration values can be accessed using the environment in any part of the application:     <pre><code>value, err := env.ConfigProvider().ConfigValue(\"server.addr\", nil)\n</code></pre></p> <p>Golang is a strongly typed language and it is impossible to use generics in this case in the current version of the language (go1.22).</p> <p>There is an additional function within the framework that helps solve the typing problem:     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/config\"\n)\n\nfunc GetServerAddr(env componego.Environment) (string, error) {\n    return config.Get[string](\"server.addr\", nil, env)\n}\n</code></pre> The shorter code appears as follows:     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/config\"\n)\n\nfunc GetServerAddr(env componego.Environment) string {\n    return config.GetOrPanic[string](\"server.addr\", nil, env)\n}\n</code></pre></p> <p>Note</p> <p>We use a dot as a separator between configuration keys to indicate different levels of nesting.</p>"},{"location":"impl/config/#configuration-processor","title":"Configuration Processor","text":"<p>Validation and transformation of configuration values can be performed using processors:     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/config\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc GetServerAddr(env componego.Environment) string {\n    return config.GetOrPanic[string](\"server.addr\", processors.Multi(\n        processors.DefaultValue(\":3030\"),\n        processors.ToString(),\n    ), env)\n}\n</code></pre></p> <p>Note</p> <p>Typing is a crucial aspect of processors. The generic type must match the processor. Otherwise, there may be an error: <pre><code>config.GetOrPanic[int64](\"server.port\", processors.Multi(\n    processors.IsRequired(),\n    processors.ToInt64(),\n), env)\n</code></pre> You should use a processor to change the type, as there is no guarantee that ApplicationConfigInit will return a value of the desired type.</p>"},{"location":"impl/config/#configuration-struct","title":"Configuration Struct","text":"<p>Application configurations can indeed become quite large, and managing each configuration key with individual processors can be inefficient. Instead, it's recommended to define a struct that contains fields corresponding to different configuration values. You can validate this struct in a single step during the initialization of the dependency injection DI container.</p> <p>Each component can have its own separate struct to describe its configuration. This allows for better modularity and separation of concerns. You can find an example of such a struct-based configuration approach here.</p>"},{"location":"impl/config/#configuration-examples","title":"Configuration Examples","text":"<p>It\u2019s recommended to create an example configuration file when you create an application or component.</p> <p>For instance, if you create a component, you should also include a file with an example of its configuration. This allows developers who use the component to easily copy and merge the example configuration file into their main application configuration file. After that, it can be read in the ApplicationConfigInit function.</p>"},{"location":"impl/dependency/","title":"Dependency Injection","text":""},{"location":"impl/dependency/#basic-information","title":"Basic Information","text":"<p>Dependency injection is a design pattern used in software engineering to achieve inversion of control between classes and their dependencies. In simpler terms, it\u2019s a technique where a class's dependencies are provided from the outside rather than created within the class itself. This approach helps decouple components, promoting easier testing, maintainability, and flexibility in your code.</p> <p>Dependencies can be provided by components and applications. Special methods within these entities are responsible for this. For example:</p> In ApplicationIn Component <pre><code>package application\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        func() SomeService {\n            return &amp;someService{}\n        },\n        // ...\n    }, nil\n}\n\nvar (\n    _ componego.Application             = (*Application)(nil)\n    _ componego.ApplicationDependencies = (*Application)(nil)\n)\n</code></pre> <pre><code>package component\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Component struct {\n}\n\n// ...\n\nfunc (c *Component) ComponentDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        func() SomeService {\n            return &amp;someService{}\n        },\n        // ...\n    }, nil\n}\n\nvar (\n    _ componego.Component             = (*Component)(nil)\n    _ componego.ComponentDependencies = (*Component)(nil)\n)\n</code></pre> <p>Now you can use the provided object in your application.</p> <p>It is recommended to use constructors to create dependencies.</p>"},{"location":"impl/dependency/#dependency-constructors","title":"Dependency Constructors","text":"<p>Pay attention to the following code example and the possible variations of what the constructor might look like:     <pre><code>func (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        NewProductRepository,\n        // ...\n    }, nil\n}\n\n// ...\n</code></pre></p> <ol> <li>A constructor returns a struct as a pointer:         <pre><code>func NewProductRepository() *ProductRepository {\n    return &amp;ProductRepository{}\n}\n</code></pre></li> <li>A constructor returns a struct as an interface:         <pre><code>func NewProductRepository() ProductRepository {\n    return &amp;productRepository{}\n}\n</code></pre></li> <li>A constructor can return an error as the latest value:        <pre><code>func NewProductRepository() (ProductRepository, error) {\n    return &amp;productRepository{}, nil\n}\n</code></pre></li> <li>A constructor can accept an unlimited number of dependencies:        <pre><code>func NewProductRepository(db * database.Provider) ProductRepository {\n    return &amp;productRepository{\n        db: db,\n    }\n}\n</code></pre></li> <li>You can even do things like this:        <pre><code>func NewProductRepository(di componego.DependencyInvoker) (ProductRepository, error) {\n    repo := &amp;productRepository{}\n    return repo, di.PopulateFields(repo)\n}\n</code></pre></li> </ol> <p>Note</p> <p>Constructors can accept and return an unlimited number of dependencies. However, they must be presented as pointers.</p> <p>It is also recommended to use interfaces, as it can be convenient in some cases.</p> <p>Like any entity in the framework, the constructor is thread-safe.</p> <p>Another way is to represent the dependency directly as an object:     <pre><code>func (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        &amp;ProductRepository{},\n        // ...\n    }, nil\n}\n\n// ...\n</code></pre></p> <p>Note</p> <p>Loops between dependencies are not allowed. If a loop occurs, you will receive an error message when starting the application.</p> <p>Note</p> <p>If the provided object implements the io.Closer interface, the Close() function will be called when the application stops.</p>"},{"location":"impl/dependency/#access-to-dependencies","title":"Access to Dependencies","text":"<p>Dependencies can be obtained in several ways. The easiest way is to use the environment.</p>"},{"location":"impl/dependency/#invoke","title":"Invoke","text":"<p>This method accepts a function as an argument, which can utilize any dependencies provided in any components or application.     <pre><code>_, err := env.DependencyInvoker().Invoke(func(service SomeService, repository SomeRepository) {\n    // ...\n})\n</code></pre> The function may also return an error as the last return value:     <pre><code>_, err := env.DependencyInvoker().Invoke(func(service SomeService) error {\n    // ...\n    return service.Action()\n})\n</code></pre> The invoked function can also return a value:     <pre><code>returnValue, err := env.DependencyInvoker().Invoke(func(service SomeService) int {\n    // ...\n    return service.Action()\n})\n// or\nreturnValue, err := env.DependencyInvoker().Invoke(func(service SomeService) (int, error) {\n    // ...\n    return service.Action()\n})\n</code></pre></p> <p>Note</p> <p>Since the return type is any, you can use a helper to obtain the correct type: <pre><code>package example\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/dependency\"\n)\n\nfunc GetValue(env componego.Environment) (int, error) {\n    intValue, err := dependency.Invoke[int](SomeFunction, env)\n    // intValue := dependency.InvokeOrPanic[int](SomeFunction, env)\n    return intValue, err\n}\n</code></pre></p> <p>You can also obtain an object for dependency injection within any function:     <pre><code>_, err := di.Invoke(func(di componego.DependencyInvoker, service SomeService) (any, error) {\n    // ...\n    return di.Invoke(service.Action)\n})\n</code></pre> However, in this case, you could use closures.</p>"},{"location":"impl/dependency/#populate","title":"Populate","text":"<p>This function populates a variable that is a pointer.     <pre><code>var service *Service\nerr := env.DependencyInvoker().Populate(&amp;service)\n</code></pre></p> <p>Note</p> <p>The type of the variable must exactly match the requested type.</p> <p>Also, note the pointer and pointer dereferences in the example above. It is expected that *Service type has been provided for dependencies.</p> <p>The difference between functions Populate and Invoke is that the first function can only accept a struct because only a struct can be a pointer. At the same time, the second function can accept arguments of any type included in the list of allowed types for dependencies.</p>"},{"location":"impl/dependency/#populatefields","title":"PopulateFields","text":"<p>Populate fills only a variable, but more often, you need to fill fields in a struct. For example:     <pre><code>type Service struct {\n    dbProvider database.Provider `componego:\"inject\"`\n}\n\n// ...\n\nservice := &amp;Service{}\nerr := env.DependencyInvoker().PopulateFields(service)\n</code></pre> This method fills only those fields that have the special tag shown in the example. All other fields are ignored. Fields can be private or public. The field type can be any one.</p> <p>If an error occurs, the method will return it.</p>"},{"location":"impl/dependency/#default-dependencies","title":"Default Dependencies","text":"<p>Each application has a set of standard dependencies through which you can access various functions of the application. The table below shows these dependencies:</p> Variable Description env componego.Environment access to the environment app componego.Application returns the current application appIO componego.ApplicationIO access to the application IO di componego.DependencyInvoker returns the dependency invoker config componego.ConfigProvider provides access to configuration <p>These are objects returned by the environment through its methods.</p> <p>Note</p> <p>Although you can get context through the environment, you cannot get context through dependencies. Use the environment directly to obtain the application context.</p> <p>Note</p> <p>Standard dependencies cannot be rewritten. You must use driver options if you want to modify them.</p>"},{"location":"impl/dependency/#rewriting-dependencies","title":"Rewriting Dependencies","text":"<p>Rewriting is one of the main features of the framework. Here\u2019s an example of how you can rewrite dependencies:     <pre><code>func (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        func() SomeService {\n            return &amp;someService1{}\n        },\n        func() SomeService {\n            return &amp;someService2{}\n        },\n        // ...\n    }, nil\n}\n\n// ...\n</code></pre> In this case, the second service will be used because it is defined after the constructor of the first service.</p> <p>The return types must match for rewriting rules to apply. This is the only condition. Constructors can accept any dependency, but the return types must match for rewriting to work.</p> <p>If you try to return a type that was not returned in the constructors above, you will receive an error.</p> <p>Note</p> <p>The only exception is the last type returned, if that type is an error.</p> <p>Rewriting dependencies is one of the key elements in creating mocks using this framework.</p> <p>Remember that according to the documentation about the order of initialization of elements in the framework, method ApplicationDependencies is called after the same function for components (ComponentDependencies). This means that you can rewrite dependencies in your application that were declared in components. You can also rewrite dependencies in components that were added in parent components.</p>"},{"location":"impl/driver/","title":"Application Driver","text":""},{"location":"impl/driver/#basic-information","title":"Basic information","text":"<p>The application driver plays a main role in Componego runtime by serving as the entry point that initializes and orchestrates all essential functions within an application. Essentially, it acts as the engine that kick-starts the execution of an application by coordinating various components, managing configurations, and initiating critical processes. This driver ensures a smooth and controlled stage setting for seamless operation.</p>"},{"location":"impl/driver/#differences-between-runner","title":"Differences between Runner","text":"<p>The difference is minimal, but the driver can be shared among many applications, initiating the basic functions of the application based on the driver's options. Driver options control various aspects of the application, including the environment factory, dependency manager, configuration manager, input reader, output writer, and error output writer. These options are flexible and can be modified since they are only options.</p> <p>In most cases, you don't need to be aware of the driver options. However, if you wish to modify any core aspects of the framework, you can explore the source code to see how it is implemented.</p>"},{"location":"impl/driver/#application-initialization-order","title":"Application initialization order","text":"Componego Flow <p>Note</p> <p>The red elements in the image can handle errors that occur in previous (or nested) functions.</p> <p>Note</p> <p>We recommend looking at this diagram again when you fully understand how to create applications and components, and the entities they provide.</p> <p>The general order in which functions are called is as follows:</p> <ol> <li>runner.Run</li> <li>driver.RunApplication</li> <li>application.ApplicationConfigInit</li> <li>application.ApplicationComponents</li> <li>component.ComponentComponents (+ getting components for each component)</li> <li>component.ComponentDependencies (for each of the active components)</li> <li>application.ApplicationDependencies</li> <li>component.ComponentInit (for each of the active components)</li> <li>application.ApplicationAction</li> <li>component.ComponentStop (for each of the active components in reverse order)</li> <li>application.ApplicationErrorHandler (If there was an error)</li> <li>exit</li> </ol> <p>Not all methods are described here (if the application or component uses these methods). This list provides a sufficient overview of the application initialization order.</p> <p>Note</p> <p>The order of initialization and method calls is crucial when rewriting elements of the application. For example, an application  can rewrite dependencies of component because a method that returns dependencies for the application object (ApplicationDependencies) is called after the same function for components (ComponentDependencies). This behavior can be particularly useful when creating mocks.</p>"},{"location":"impl/environment/","title":"Application Environment","text":""},{"location":"impl/environment/#basic-information","title":"Basic information","text":"<p>The environment package serves as a comprehensive solution for managing an application runtime. This package not only provides access to dependency injection (DI) management but also includes features for handling application active components, configuration, application mode, IO and global context.</p>"},{"location":"impl/environment/#how-to-get-environment","title":"How to get environment","text":"<p>The environment can be accessed in several ways. The first and easiest way is to get this object in the application action:     <pre><code>func (a *Application) ApplicationAction(env componego.Environment, _ []string) (int, error) {\n    env.GetContext()\n    env.Application()\n    env.ApplicationIO()\n    env.ApplicationMode()\n    env.Components()\n    env.DependencyInvoker()\n    env.ConfigProvider()\n\n    // ...\n    return componego.SuccessExitCode, nil\n}\n\nvar _ componego.Application = (*Application)(nil)\n</code></pre></p> <p>You can also get this object via DI:     <pre><code>type MyType struct {\n    env componego.Environment `componego:\"inject\"`\n}\n\nfunc (m *MyType) Method() {\n    if m.env.ApplicationMode() == componego.DeveloperMode {\n        // ...\n    }\n}\n</code></pre> or     <pre><code>err := dependencyInvoker.Invoke(func(env componego.Environment) {\n    // ...\n})\n</code></pre></p> <p>or another ways described in the documentation about DI.</p> <p>Note</p> <p>The environment object cannot be rewritten by rewritten DI objects. This object is present in any application.</p>"},{"location":"impl/environment/#how-to-use-environment","title":"How to use environment","text":"Method Description Documentation env.GetContext() returns a current application context open env.SetContext(newCtx) sets a new application context open env.Application() returns a current application object open env.ApplicationIO() returns an object for getting application input and output open env.ApplicationMode() returns the mode in which the application is started open env.Components() returns a sorted list of active application components open env.DependencyInvoker() returns an object to invoke dependencies open env.ConfigProvider() returns an object for getting config open <p>This serves as a universal key for accessing any part of the application.</p>"},{"location":"impl/environment/#application-context","title":"Application Context","text":"<p>It is recommended to use the application context to run various functions. You can also replace the current context with another one, but the new context must inherit from the previous main context:     <pre><code>package component\n\nimport (\n    \"context\"\n    \"time\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/component\"\n)\n\nfunc NewComponent() componego.Component {\n    factory := component.NewFactory(\"example\", \"0.0.1\")\n    factory.SetComponentInit(func(env componego.Environment) error {\n        ctx, cancelCtx := context.WithTimeout(env.GetContext(), time.Second*100)\n        // ...\n        return env.SetContext(ctx)\n    })\n    return factory.Build()\n}\n</code></pre></p>"},{"location":"impl/environment/#application-io","title":"Application IO","text":"<p>If you want to output (or receive) some text to (from) the console, you must use special methods:     <pre><code>func (a *Application) ApplicationAction(env componego.Environment, _ []string) (int, error) {\n    appIO := env.ApplicationIO()\n    _, _ = fmt.Fprintln(appIO.OutputWriter(), \"your text\")\n    _, _ = fmt.Fprintln(appIO.ErrorOutputWriter(), \"your error text\")\n    reader := bufio.NewReader(appIO.InputReader())\n    text, _ := reader.ReadString('\\n')\n}\n</code></pre></p>"},{"location":"impl/processor/","title":"Processors","text":""},{"location":"impl/processor/#basic-information","title":"Basic information","text":"<p>Processors are special functions that convert variables of one type into another and validate them.</p> <p>On the previous page you have seen the example of using processors:     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/config\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc GetConnectionName(env componego.Environment) string {\n    return config.GetOrPanic[string](\n        \"connection.name\",\n        processors.IsRequired(),\n        env,\n    )\n}\n</code></pre></p>"},{"location":"impl/processor/#default-processors","title":"Default Processors","text":"Function Description processors.ToBool() converts the value to boolean processors.IsBool() checks whether the value is a boolean value processors.ToInt64() converts the value to int64 processors.ToFloat64() converts the value to float64 processors.ToString() converts the value to string processors.IsRequired() checks that the value is present (not nil) processors.DefaultValue(anyValue) sets the default value if the previous value is nil"},{"location":"impl/processor/#custom-processor","title":"Custom Processor","text":"<p>There are 2 simple ways to create it:</p> Long codeShort code <pre><code>package processor\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Processor struct{}\n\nfunc (p *Processor) ProcessData(value any) (any, error) {\n    // convert a value to another or validate a value\n    // if there is an error, then you must return it\n    return newValue, nil\n}\n\nvar _ componego.Processor = (*Processor)(nil)\n</code></pre> <pre><code> package processor\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc NewProcessor() componego.Processor {\n    return processors.New(func(value any) (any, error) {\n        // convert a value to another or validate a value\n        // if there is an error, then we must return it\n        return newValue, nil\n    })\n}\n</code></pre> <p>Note</p> <p>Like in other parts of the application, you can use dependencies within processors: <pre><code>package processor\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Processor struct {\n    env componego.Environment `componego:\"inject\"`\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/processor/#multi-processor","title":"Multi Processor","text":"<p>This can be implemented using processors.Multi, which allows for combining multiple functions into one:     <pre><code>package processor\n\nimport (\n    \"strings\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc NewProcessor() componego.Processor {\n    return processors.Multi(\n        processors.ToString(),\n        processors.New(func(value any) (any, error) {\n            return strings.Split(value.(string), \",\"), nil\n        }),\n    )\n}\n</code></pre> Look at the example above: we do not check if the value is a string in the second processor, as we are confident it will be converted to a string in the first processor.</p> <p>This is a chain of function calls executed sequentially. If an error occurs in any function, the chain will be interrupted.</p>"},{"location":"impl/processor/#processor-as-validator","title":"Processor As Validator","text":"<p>You can use processors not only to convert data to another format but also for validation:     <pre><code>package processor\n\nimport (\n    \"fmt\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc ToAge() componego.Processor {\n    return processors.Multi(\n        processors.ToInt64(),\n        processors.New(func(value any) (any, error) {\n            age := value.(int64)\n            if age &lt; 21 {\n                return nil, fmt.Errorf(\"invalid age: %d\", age)\n            }\n            return age, nil\n        }),\n    )\n}\n</code></pre> You can also use third-party libraries to validate specific rules:     <pre><code>package processor\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/processors\"\n    \"github.com/go-playground/validator/v10\" // third-party library\n)\n\nvar validate = validator.New()\n\nfunc ToAge() componego.Processor {\n    return processors.Multi(\n        processors.ToInt64(),\n        processors.New(func(value any) (any, error) {\n            return value, validate.Var(value, \"required,numeric,min=21\")\n        }),\n    )\n}\n</code></pre></p> <p>Note</p> <p>The framework is designed as a way to run an application. You should avoid using framework functions within the main loop of your application. Instead, utilize the framework solely for initializing the main application loop.</p>"},{"location":"impl/runner/","title":"Application Runner","text":""},{"location":"impl/runner/#basic-information","title":"Basic Information","text":"<p>This entity is responsible for running the application using the driver.     <pre><code>package main\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/runner\"\n\n    \"github.com/componego/componego/examples/hello-app/internal/application\"\n)\n\nfunc main() {\n    runner.RunAndExit(application.New(), componego.ProductionMode)\n}\n</code></pre> This line in the main function is sufficient to start your application.</p> <p>The function runner.RunAndExit runs the application and exits the program with an exit code after the application stops.</p> <p>Note</p> <p>If the application completes with an error, the exit code will not equal 0 (componego.SuccessExitCode).</p> <p>You can also use runner.Run, which starts the application but does not exit it:     <pre><code>package main\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/runner\"\n\n    \"github.com/componego/componego/examples/hello-app/internal/application\"\n)\n\nfunc main() {\n    exitCode := runner.Run(application.New(), componego.ProductionMode)\n    // ...\n}\n</code></pre></p> <p>There are also methods RunWithContext and RunGracefullyAndExit, which allow you to run the application using a custom context or facilitate a graceful shutdown.</p>"},{"location":"impl/runner/#application-mode","title":"Application Mode","text":"<p>As you can see, you can run the application in different modes. By default, there are several modes available:</p> Name Description componego.ProductionMode for production environment componego.DeveloperMode for developers componego.TestMode for application tests <p>But you can add any mode you want.</p> <p>You can retrieve the application mode through the environment:     <pre><code>if env.ApplicationMode() == componego.DeveloperMode {\n    // ...\n}\n</code></pre></p> <p>Note</p> <p>You should always use production mode when running your application on a production server. It is also recommended to use test mode when executing the application in tests.</p> <p>Note</p> <p>We strongly recommend using multiple application entry points, as demonstrated in this example.</p> <p>We believe that applications should be aware of the mode in which they will be launched even before execution. For example, this approach allows you to read different configurations based on the environment, rather than constructing the environment according to the configuration.</p>"},{"location":"impl/runner/#custom-runner","title":"Custom Runner","text":"<p>The custom runner is significant as it serves as an entry point where you can begin modifying the core of the framework to meet your specific requirements.</p> <p>Note</p> <p>If you are a beginner with our framework, please skip this section and return to it after you have thoroughly read the rest of the documentation.</p>"},{"location":"impl/runner/#specific-driver-options","title":"Specific Driver Options","text":"<p>This is related to the application driver, but you can manage it through the runner. The options are factories that implement all default entities provided by the framework. So this is the key (but not the only one) how you can replace the core of the framework with your code.</p> <p>For example, you can pass additional options to your application. Let's create a new Run function that accepts arguments:     <pre><code>package custom_runner\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/driver\"\n    \"github.com/componego/componego/impl/runner/unhandled-errors\"\n)\n\nfunc Run(app componego.Application, appMode componego.ApplicationMode, additionalOptions any) int {\n    d := driver.New(&amp;driver.Options{\n        Additional: additionalOptions,\n        // ... other options\n    })\n    exitCode, err := d.RunApplication(context.Background(), app, appMode)\n    if err != nil {\n        _, _ = fmt.Fprint(os.Stderr, unhandled_errors.ToString(err, appMode, unhandled_errors.GetHandlers()))\n    }\n    return exitCode\n}\n</code></pre></p> <p>Review the options which are available in the driver code to ensure you can control everything.</p> <p>Note</p> <p>The ability to replace the core of the framework is crucial because it allows for flexibility and customization. This means you are not bound to the default implementations of certain functions in the framework. Instead, you can substitute them with alternative methods that comply with the required interfaces. This feature enhances the adaptability of your application, enabling you to tailor functionalities to meet specific needs or to integrate with other systems more effectively.</p> <p>However, even more critical is the ability to replace business logic easily, as this functionality can be instrumental in creating mocks and other testing scenarios. The framework supports this capability as well. We've covered the details on other pages, highlighting how you can substitute specific business logic implementations to facilitate testing and improve code maintainability.</p>"},{"location":"impl/runner/#errors-handing","title":"Errors Handing","text":"<p>Note</p> <p>It is recommended to use a special application method ApplicationErrorHandler to catch global errors or panic.</p> <p>At the runner level you can handle errors that were not handled at all previous levels.</p> <p>Based on the previous example, the following lines can be added for error handling:     <pre><code>func Run(app componego.Application, appMode componego.ApplicationMode) int {\n    d := driver.New(nil)\n    exitCode, err := d.RunApplication(context.Background(), app, appMode)\n    if err != nil {\n        handlers := unhandled_errors.GetHandlers()\n        _, _ = fmt.Fprint(os.Stderr, unhandled_errors.ToString(err, appMode, handlers))\n    }\n    return exitCode\n}\n</code></pre> You can convert the error into a string using specific handlers and display it to users. This approach allows for a user-friendly presentation of error messages. You can customize the error handling logic to fit your application\u2019s needs. Here's how you might implement this:     <pre><code>handlers := unhandled_errors.GetHandlers()\nhandlers.AddBefore(\n    \"company:my-handler-name\",\n    func(err error, writer io.Writer, appMode componego.ApplicationMode) bool {\n        if errors.Is(err, MyError) {\n            // ...\n            return true // return true if the error is processed\n        }\n        return false\n    },\n    \"componego:vendor-proxy\",\n)\n_, _ = fmt.Fprint(os.Stderr, unhandled_errors.ToString(err, appMode, handlers))\n</code></pre></p> <p>In addition to function AddBefore, t, there are numerous other functions designed for handling errors in a specific sequence using an ordered map. For a complete list of these methods, you can refer to the source code here.</p> <p>Note</p> <p>Don't hesitate to explore the core of the framework and copy methods to modify them for your specific requirements. However, it's important to adhere to the rewriting rules outlined by the framework.</p>"},{"location":"tests/mock/","title":"Application Mock","text":""},{"location":"tests/mock/#basic-example","title":"Basic Example","text":"<p>If you want to replace a part of your application for testing, you can do so easily.</p> <p>Use the example of the application below to see how to create a mock:     <pre><code>package mocks\n\nimport (\n    \"github.com/componego/componego\"\n\n    \"secret.com/project-x/internal/application\"\n)\n\ntype ApplicationMock struct {\n    *application.Application\n}\n\nfunc NewApplicationMock() *ApplicationMock {\n    return &amp;ApplicationMock{\n        Application: application.New(),\n    }\n}\n\n// ... other methods\n\nvar (\n    _ componego.Application = (*ApplicationMock)(nil)\n    // ...\n)\n</code></pre> We use inheritance. In a child struct (mock), you can override methods to return new values.</p> <p>Here's an example of overriding dependencies, but you can add any other method:     <pre><code>func (a *ApplicationMock) ApplicationDependencies() ([]componego.Dependency, error) {\n    dependencies, err := a.Application.ApplicationDependencies()\n    dependencies = append(\n        dependencies,\n        func() Service {\n            return &amp;mockService{}\n        },\n        // ...\n        )\n    return dependencies, err\n}\n</code></pre> We call the parent method and then add new data.</p> <p>It is explained how to run the mock on the next documentation page.</p>"},{"location":"tests/mock/#rewriting-rules","title":"Rewriting Rules","text":"<p>We've already described this on previous documentation pages for each framework entity, but let's sum it up.</p> <p>Note</p> <p>We follow the order in which the methods are called. The last methods called may override the return data of the previous methods.</p>"},{"location":"tests/mock/#for-components","title":"For Components","text":"<p>If several components the same identifier, the component specified last will take precedence.</p>"},{"location":"tests/mock/#for-dependencies","title":"For Dependencies","text":"<p>The last dependencies in the list are applied.</p> <p>If you use a constructor for dependencies, the last constructor will overwrite the dependencies if its return types match those of the constructor you want to replace.</p> <p>You will encounter an error if you return a constructor that produces a different set of types, except for the last returned type if it is an error.</p> <p>If you use an object directly instead of a constructor, you can overwrite this value with either the same object or a constructor that returns an object of the same type.</p> <p>Note</p> <p>Objects returned by the environment methods cannot be overwritten..</p>"},{"location":"tests/mock/#for-configuration","title":"For Configuration","text":"<p>Everything is straightforward here. You need to read data from another resource.</p> <p>For example, you can use the application mode to read various configurations:     <pre><code>package application\n\nimport (\n    \"fmt\"\n\n    \"github.com/componego/componego\"\n    // ...\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationConfigInit(appMode componego.ApplicationMode, options any) (map[string]any, error) {\n    switch appMode {\n    case componego.ProductionMode:\n        return config_reader.Read(\"./config/production.config.json\")\n    case componego.DeveloperMode:\n        return config_reader.Read(\"./config/developer.config.json\")\n    case componego.TestMode:\n        return config_reader.Read(\"./config/test.config.json\")\n    default:\n        return nil, fmt.Errorf(\"not supported application mode: %d\", appMode)\n    }\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationConfigInit = (*Application)(nil)\n)\n</code></pre></p> <p>You can also override this method in a mock to return a map with a different configuration required for your test.</p>"},{"location":"tests/mock/#for-framework-core","title":"For Framework Core","text":"<p>If you want to replace something within the framework, you can use driver options.</p> <p>Don't hesitate to copy core functions to make the necessary changes for your project. We would also appreciate any any suggestion or pull request that can help develop this project.</p>"},{"location":"tests/runner/","title":"Tests Runner","text":""},{"location":"tests/runner/#basic-example","title":"Basic Example","text":"<p>This is the simplest way:     <pre><code>package tests\n\nimport (\n    \"testing\"\n\n    \"github.com/componego/componego/tests/runner\"\n\n    \"secret.com/project-x/tests/mocks\"\n)\n\nfunc TestExample(t *testing.T) {\n    env, cancelEnv := runner.CreateTestEnvironment(t, mocks.NewApplicationMock(), nil)\n    t.Cleanup(cancelEnv)\n    // ... here you can use application environment.\n}\n</code></pre> In the example above, we created the new environment based on the application mock. You can use this environment to run the necessary functions in your tests.</p> <p>The last argument of the function accepts the test options, including driver options, that will be applied to the current test.</p> <p>When the environment is canceled, all necessary functions will be called to stop the application.</p> <p>The framework is thread-safe so you can run tests in parallel. However, your personal code or the code of third-party libraries you use may not be thread-safe.</p> <p>Note</p> <p>In the example above, you can see how to test an application.</p> <p>To test component, you must create an application that depends only on that component. For example, this way you can configure a component, because this method is in any application.</p>"},{"location":"tests/runner/#test-mode","title":"Test Mode","text":"<p>In tests, the application should be launched in componego.TestMode. There are different application launch modes. However, for tests, it is recommended to use componego.TestMode.</p> <p>The code above runs the application in this mode, so please consider this detail in your implementation.</p>"},{"location":"warnings/goroutine-leak/","title":"Goroutine leak when exiting the application","text":"<p>Only in development mode, you may see warnings when exiting the application that some goroutines are still running.</p> <p>This means that, in addition to the main goroutine, other goroutines are also running. In any case, all goroutines will be terminated after exiting the application. However, some goroutines may be performing important work that will be terminated forcefully and possibly unsuccessfully.</p> <p>Of course, you cannot guarantee that 100% of all goroutines will be completed, but you should strive for this.</p> <p>Some packages run goroutines that continuously monitor events.</p> <p>Here is an example of code and how you can detect a goroutine leak:     <pre><code>package main\n\nimport (\n    \"os\"\n    \"os/signal\"\n    \"runtime/pprof\"\n    \"syscall\"\n)\n\nfunc main() {\n    interruptChan := make(chan os.Signal, 1)\n    signal.Notify(interruptChan, os.Interrupt, syscall.SIGTERM)\n    // ...\n    signal.Stop(interruptChan)\n    // ...\n    _ = pprof.Lookup(\"goroutine\").WriteTo(os.Stdout, 1)\n}\n</code></pre> The output of this program will be approximately as follows:</p> <p></p> <p>As you can see, we still have a goroutine that monitors signals. This goroutine is safe; however, there may be other goroutines present.</p> <p>Please ignore this warning if there are no unwanted goroutine leaks.</p>"}]}