{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"get-started/","title":"Get Started","text":"<p>The Componego Framework seamlessly integrates component, dependency injection, configuration, event and error handling, providing a robust foundation for building modular, scalable, and maintainable software systems.</p> <p>At its core, the framework embraces a component-based architecture. These components encapsulate specific functionalities and seamlessly integrate to construct larger, more complex applications. Promoting code reusability and maintainability, the component framework allows developers to work on independent units, fostering efficient development and a cohesive application architecture.</p> <p>Main features of the framework:</p> <ol> <li>well-organized application initialization process and smallest main function</li> <li>simple and powerful components</li> <li>flexible dependency injections without code generation</li> <li>the framework core does not depend on third-party packages</li> <li>easy integration with previously written code and third-party packages</li> <li>no impact on the business logic code of your application. You will write and organize your business logic as you did before</li> <li>any entity of the framework can be replaced without changing previously written code</li> <li>good documentation for developers</li> </ol> <p>The framework does not provide a database connection, web server, queue and other things. Instead, we provide the ability to conveniently integrate these things into components for later reuse in your projects. You can use absolutely anything you want. There are no limits on packages. Any existing Golang package can be easily wrapped in our components.</p> <p>Note</p> <p>The documentation is a brief description of the main functions of the framework. You may find some things complicated, but for each part that is described in another section, we add links.</p> <p>You need to create an application or component using this framework to fully understand the framework. Don't be afraid to open the source code. There you will find many interesting functions that were not described in the documentation.</p> <p>How to create an application?</p> <p>How to run an application?</p> <p>How to create a component?</p> <p>How to use dependency injections?</p> <p>How to use configuration?</p> <p>How to handle errors?</p> <p>How to create mocks?</p> <p>How to create tests?</p>"},{"location":"contribution/guide/","title":"Contribution Guide","text":"<p>This section is only for those who want to contribute to the framework.</p> <p>Contributions can be new features, changes to existing features, tests, documentation (such as developer guides, examples, or specifications), bug fixes, optimizations, or just good suggestions.</p> <p>The main rules for making changes to the codebase are as follows:</p> <ol> <li>We use pre-commit to run a custom hook when committing code. Please install it.</li> <li>After making changes please run tests using our utility:        <pre><code>% make tests\n</code></pre></li> <li>Please do not include third-party packages in the framework codebase.</li> <li>Before creating a pull request or merge to our repository, please do a git rebase.</li> <li>The language of communication is English. All commits, comments, tasks, and questions must be written in English.</li> </ol> <p>If you like our framework, you can tell your friends about it, which will help this project develop further.</p> <p>Twitter | X LinkedIn Facebook</p> <p> Thank you.</p>"},{"location":"impl/application/","title":"Application","text":""},{"location":"impl/application/#basic-application","title":"Basic Application","text":"<p>The application is a struct with a set of methods that describe the elements of the application.</p> <p>Let's try to create your first application and launch it.     <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/application\"\n    \"github.com/componego/componego/impl/runner\"\n)\n\ntype Application struct {\n}\n\nfunc (a *Application) ApplicationName() string {\n    return \"Hello World App\"\n}\n\nfunc (a *Application) ApplicationAction(env componego.Environment, options any) (int, error) {\n    _, err := fmt.Fprintln(env.ApplicationIO().OutputWriter(), \"Hello World!\")\n    return application.ExitWrapper(err)\n}\n\nfunc main() {\n    runner.RunAndExit(&amp;Application{}, componego.ProductionMode)\n}\n</code></pre> Save this code to a file and run it without arguments.</p> <p>Don't forget to initialize go mod and download all dependencies.     <pre><code>% go run main.go\nHello world!\n</code></pre></p> <p>The source code for this application example is available here.</p> <p>About runner is written in the next page.</p>"},{"location":"impl/application/#mandatory-methods","title":"Mandatory methods","text":""},{"location":"impl/application/#applicationname","title":"ApplicationName","text":"<p>The function returns the application name.     <pre><code>func (a *Application) ApplicationName() string {\n    return \"The Best Application\"\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/application/#applicationaction","title":"ApplicationAction","text":"<p>The function describes the main action of the current application.     <pre><code>func (a *Application) ApplicationAction(env componego.Environment, options any) (int, error) {\n    // ...\n    return componego.SuccessExitCode, nil\n}\n\n// ...\n</code></pre> In this function you can write business logic for your application.</p> <p>The first argument of this method is an environment, with which you can access any function of the framework.</p> <p>The second argument is additional options that you can pass to your application using the driver.</p>"},{"location":"impl/application/#optional-methods","title":"Optional methods","text":""},{"location":"impl/application/#applicationcomponents","title":"ApplicationComponents","text":"<p>The application may depend on components:     <pre><code>func (a *Application) ApplicationComponents() ([]componego.Component, error) {\n    return []componego.Component{ /* ... */ }, nil\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/application/#applicationdependencies","title":"ApplicationDependencies","text":"<p>It can provide dependencies:     <pre><code>func (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{ /* ... */ }, nil\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/application/#applicationconfiginit","title":"ApplicationConfigInit","text":"<p>The application can read the configuration:     <pre><code>func (a *Application) ApplicationConfigInit(appMode componego.ApplicationMode, options any) (map[string]any, error) {\n    return map[string]any{\n        \"config.key\": \"config.value\",\n    }, nil\n}\n\n// ...\n</code></pre> You can return different configuration depending on the mode the application is running in.</p> <p>The second argument of method is additional options. These are the same options as in the application action.</p>"},{"location":"impl/application/#applicationerrorhandler","title":"ApplicationErrorHandler","text":"<p>By default, there is also a method that handles all your errors that were not handled previously:     <pre><code>func (a *Application) ApplicationErrorHandler(err error, appIO componego.ApplicationIO, appMode componego.ApplicationMode) error {\n    if errors.Is(err, MyError) {\n        // ...\n        err = nil\n    } else {\n        // ...\n    }\n    return err\n}\n</code></pre> This method also intercepts global panic in the application.</p> <p>Unhandled errors returned by this method will be received and processed by the runner at the core level.</p> <p>You can also catch errors at the component level.</p> <p>Note</p> <p>For more clarity and compile time validation you can add the following code: <pre><code>var (\n    _ componego.Application             = (*Application)(nil)\n    _ componego.ApplicationComponents   = (*Application)(nil)\n    _ componego.ApplicationDependencies = (*Application)(nil)\n    _ componego.ApplicationConfigInit   = (*Application)(nil)\n    _ componego.ApplicationErrorHandler = (*Application)(nil)\n)\n</code></pre> The names of interface correspond to the logic they implement.</p> <p>It is recommended to always add such validation in order to easily find and fix problems in the code in case changes are made to interface methods in future versions of the framework.</p> <p>Note</p> <p>You can also add your own methods and implement your custom logic to them, because an application is a struct that just implements interfaces.</p> <p>Note</p> <p>Pay special attention to the order in which methods are called. This will help you understand the application initialization process.</p>"},{"location":"impl/application/#application-factory","title":"Application Factory","text":"<p>There is also a short code for creating the application. However, we do not recommend using this method of creating an application.     <pre><code>package main\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/application\"\n    \"github.com/componego/componego/impl/runner\"\n)\n\nfunc main() {\n    factory := application.NewFactory(\"Application Name\")\n    factory.SetApplicationDependencies(func() ([]componego.Dependency, error) {\n        return []componego.Dependency{ /* ... */ }, nil\n    })\n    factory.SetApplicationAction(func(env componego.Environment, options any) (int, error) {\n        // ...\n        return componego.SuccessExitCode, nil\n    })\n    // ... other methods.\n    runner.RunAndExit(factory.Build(), componego.ProductionMode)\n}\n</code></pre> The factory has different Set* methods that correspond to the methods described above.</p>"},{"location":"impl/application/#application-skeleton","title":"Application Skeleton","text":"<p>You can quickly create an application skeleton using the following ways:     <pre><code>curl -sSL https://raw.githubusercontent.com/componego/componego/master/tools/create-basic-app.sh | sh\n</code></pre> or     <pre><code>wget -O - https://raw.githubusercontent.com/componego/componego/master/tools/create-basic-app.sh | sh\n</code></pre></p> <p>On Windows, you can run the above commands with Git Bash.</p> <p>This command will create a componego-basic-app folder with the most basic version of the application, based on which you can begin development.</p> <p>An example of a full-fledged application using our framework can be found here.</p> <p>To learn more, visit other documentation pages.</p>"},{"location":"impl/component/","title":"Application Components","text":""},{"location":"impl/component/#basic-component","title":"Basic Component","text":"<p>A component is a modular, reusable piece of code that performs a specific function in a larger application. The components are designed as independent, self-contained units that can be easily integrated into an application.</p> <p>Components are not microservices. These are folders that contain different functionality. To describe what functionality a component depends on and what functionality the component provides, we use a struct with a set of different methods.</p> <p>The basic component looks like this:     <pre><code>package component\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Component struct {\n}\n\nfunc NewComponent() *Component {\n    return &amp;Component{}\n}\n\nfunc (c *Component) ComponentIdentifier() string {\n    return \"company-name:component-name\"\n}\n\nfunc (c *Component) ComponentVersion() string {\n    return \"0.0.1\"\n}\n\nvar (\n    _ componego.Component = (*Component)(nil)\n)\n</code></pre> This component doesn't do anything because it lacks the methods the various functions provide.</p> <p>Look at the methods that the component can provide in the documentation below in the next section. For now, let's look at how you can add a component to your application:     <pre><code>package application\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationComponents() ([]componego.Component, error) {\n    return []componego.Component{\n        NewComponent(),\n    }, nil\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationComponents = (*Application)(nil)\n)\n</code></pre></p>"},{"location":"impl/component/#mandatory-methods","title":"Mandatory methods","text":""},{"location":"impl/component/#componentidentifier","title":"ComponentIdentifier","text":"<p>This function returns the component ID.     <pre><code>func (c *Component) ComponentIdentifier() string {\n    return \"company-name:component-name\"\n}\n\n// ...\n</code></pre> If the identifier in several components is the same, then the last component will be used. This can be used to rewrite components.</p>"},{"location":"impl/component/#componentversion","title":"ComponentVersion","text":"<p>This function returns the component version.     <pre><code>func (c *Component) ComponentVersion() string {\n    return \"0.0.1\"\n}\n\n// ...\n</code></pre> The version must match the SemVer format.</p> <p>Note</p> <p>It is recommended to always increase the component version if you make changes to the component.</p>"},{"location":"impl/component/#optional-methods","title":"Optional methods","text":"<p>Note</p> <p>The component struct is similar to the application struct. However, there are slight differences in the methods.</p>"},{"location":"impl/component/#componentcomponents","title":"ComponentComponents","text":"<p>The component may depend on components:     <pre><code>func (a *Component) ComponentComponents() ([]componego.Component, error) {\n    return []componego.Component{ /* ... */ }, nil\n}\n\n// ...\n</code></pre></p> <p>Note</p> <p>The order in which the components are loaded depends on the dependencies between the components.</p> <p>This also affects the rewriting of components. The components that are listed last rewrite the components that were added first (if they have the same identifier).</p>"},{"location":"impl/component/#componentdependencies","title":"ComponentDependencies","text":"<p>Like an application, it can provide dependencies:     <pre><code>func (a *Component) ComponentDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{ /* ... */ }, nil\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/component/#componentinit","title":"ComponentInit","text":"<p>This is a function that is called in order of dependencies between components. You can add some of your own logic to the method.     <pre><code>func (a *Component) ComponentInit(env componego.Environment) error {\n    // ...\n    return nil\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/component/#componentstop","title":"ComponentStop","text":"<p>This method is called before component stop. You can handle previous error (return a new or old error).     <pre><code>func (a *Component) ComponentStop(env componego.Environment, prevErr error)  error {\n    // ...\n    return prevErr\n}\n\n// ...\n</code></pre></p> <p>Note</p> <p>For more clarity and compile time validation you can add the following code: <pre><code>var (\n    _ componego.Component             = (*Component)(nil)\n    _ componego.ComponentComponents   = (*Component)(nil)\n    _ componego.ComponentDependencies = (*Component)(nil)\n    _ componego.ComponentInit         = (*Component)(nil)\n    _ componego.ComponentStop         = (*Component)(nil)\n)\n</code></pre> The names of interface correspond to the logic they implement.</p> <p>It is recommended to always add such validation in order to easily find and fix problems in the code in case changes are made to interface methods in future versions of the framework.</p>"},{"location":"impl/component/#initialization-rewriting","title":"Initialization &amp; Rewriting","text":"<p>Take a look at the following example:     <pre><code>package application\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/qcomponents/database\"\n\n    myDatabase \"secret.com/project-x/components/database\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationComponents() ([]componego.Component, error) {\n    return []componego.Component{\n        database.NewComponent(),\n        // ...\n        myDatabase.NewComponent(),\n    }, nil\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationComponents = (*Application)(nil)\n)\n</code></pre> If both connected components have the same identifier, then only the last component will be used.</p> <p>Note</p> <p>You can get a list of active components through the environment. <pre><code>activeAndSortedComponents := env.Components()\nfor _, component := range activeAndSortedComponents {\n    _, _ = fmt.Fprintf(\n        env.ApplicationIO().OutputWriter(),\n        \"identifier: %s, version: %s, struct type: %T\\n\",\n        component.ComponentIdentifier(), component.ComponentVersion(), component,\n    )\n}\n</code></pre> As you can see, we print the unique ID in the loop so you can see which components are currently in use.</p> <p>Let's look at a more complex example where components can depend on other components.</p> <p>For a better understanding, let's assume that each component color represents a component with the same identifier. The same component can be reused by other components at different levels of dependencies between them.</p> <p> </p> First Example of Components Initialization <p>We see that this tree of components has been converted into such a sorted list. This is a list of active components in our application.</p> <p>You can see here how components are rewritten.</p> <p>Note</p> <p>In fact, the sorted list can be anything. This depends on the implementation of the component manager (as we know from other documentation pages, absolutely everything in our framework can be replaced). However, any manager implementation must ensure that components are loaded based on the dependencies between the components.</p> <p>The framework guarantees that the order of loading components in your application will always be the same unless there are changes in the dependencies between components.</p> <p>Let's look at another example where we just moved the red component down.</p> <p> </p> Second Example of Components Initialization <p>As you can see, the list has not changed, but the components from other levels are active. This is how component rewriting works.</p> <p>In short:</p> <ol> <li>Components can be rewritten if they have the same identifier.    Active components are components that are last in the list (taking into account the levels between components).</li> <li>initialization order of components is always the same unless you change the list order of child components.</li> </ol>"},{"location":"impl/component/#component-factory","title":"Component Factory","text":"<p>There is also a short code for creating the component.</p> <p>This is the same thing as for the application.     <pre><code>package component\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/component\"\n)\n\nfunc NewComponent() componego.Component {\n    factory := component.NewFactory(\"identifier\", \"0.0.1\")\n    factory.SetComponentInit(func(env componego.Environment) error {\n        // ...\n        return nil\n    })\n    // ... other methods.\n    return factory.Build()\n}\n</code></pre></p>"},{"location":"impl/config/","title":"Configuration","text":""},{"location":"impl/config/#basic-information","title":"Basic Information","text":"<p>Configuration is an important part of every application.</p> <p>The framework has a single point for reading the configuration. This is a special method that you can add to the application struct:     <pre><code>package application\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationConfigInit(appMode componego.ApplicationMode, options any) (map[string]any, error) {\n    return map[string]any{\n        \"config.key1\": \"config.value1\",\n        \"config.key2\": \"config.value2\",\n        // ...\n    }, nil\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationConfigInit = (*Application)(nil)\n)\n</code></pre> As you can see, this method returns a map with configuration keys and values.</p> <p>You can also return an error if there was an error reading the configuration.</p> <p>Note</p> <p>Since the method accepts the environment, you can return different configurations depending on the mode in which the application is running.</p> <p>This method is called only once and should return the configuration for the application and all components within that application.</p>"},{"location":"impl/config/#configuration-reader","title":"Configuration Reader","text":"<p>You can read the configuration in different ways as you like.</p> <p>For example, you can use third-party libraries to get the configuration. However, your function or library must return a variable of type map[string]any.     <pre><code>package application\n\nimport (\n    \"fmt\"\n\n    \"github.com/componego/componego\"\n    \"github.com/spf13/viper\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationConfigInit(appMode componego.ApplicationMode, options any) (map[string]any, error) {\n    switch appMode {\n    case componego.ProductionMode:\n        return ConfigReader(\"./config/production.config.json\")\n    // ...\n    default:\n        return nil, fmt.Errorf(\"not supported application mode: %d\", appMode)\n    }\n}\n\nfunc ConfigReader(filename string) (map[string]any, error) {\n    // This function should be placed in a separate package.\n    v := viper.New()\n    v.SetConfigFile(filename)\n    if err := v.ReadInConfig(); err != nil {\n        return nil, err\n    }\n    return v.AllSettings(), nil\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationConfigInit = (*Application)(nil)\n)\n</code></pre></p> <p>You can also add post-processing of values after reading the configuration:     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego/impl/environment/managers/config\"\n    \"github.com/spf13/viper\"\n)\n\nfunc ConfigReader(filename string) (map[string]any, error) {\n    // This function should be placed in a separate package.\n    v := viper.NewWithOptions()\n    // ...\n    settings := v.AllSettings()\n    return settings, config.ProcessVariables(settings)\n}\n</code></pre></p> <p>This function converts the following values:     <pre><code>{\n    \"server\": {\n        \"addr\": \":${ENV:APP_PORT}\"\n    }\n}\n</code></pre> in:     <pre><code>{\n    \"server\": {\n        \"addr\": \":1234\"\n    }\n}\n</code></pre> You can also use the default value after pipe:     <pre><code>{\n    \"server\": {\n        \"addr\": \":${ENV:APP_PORT|1234}\"\n    }\n}\n</code></pre></p> <p>We have described the map that function ApplicationConfigInit will return. The next section describes how to get this value in your application or component.</p>"},{"location":"impl/config/#configuration-getter","title":"Configuration Getter","text":"<p>The configuration value can be obtained using the environment in any part of the application:     <pre><code>value, err := env.ConfigProvider().ConfigValue(\"server.addr\", nil)\n</code></pre></p> <p>Golang is a strongly typed language and it is impossible to use generics in this case in the current version of the language (go1.22).</p> <p>There is an additional function inside the framework that helps solve the typing problem:     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/config\"\n)\n\nfunc GetServerAddr(env componego.Environment) (string, error) {\n    return config.Get[string](\"server.addr\", nil, env)\n}\n</code></pre> The shorter code looks like this:     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/config\"\n)\n\nfunc GetServerAddr(env componego.Environment) string {\n    return config.GetOrPanic[string](\"server.addr\", nil, env)\n}\n</code></pre></p> <p>Note</p> <p>We use a dot as a separator between configuration keys for different levels of nesting.</p>"},{"location":"impl/config/#configuration-processor","title":"Configuration Processor","text":"<p>Validation and transformations of configuration values can be done using processors.     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/config\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc GetServerAddr(env componego.Environment) string {\n    return config.GetOrPanic[string](\"server.addr\", processors.Multi(\n        processors.DefaultValue(\":3030\"),\n        processors.ToString(),\n    ), env)\n}\n</code></pre></p> <p>Note</p> <p>Typing is an important part of processors. The generic must meet the processor. Otherwise, there may be an error. <pre><code>config.GetOrPanic[int64](\"server.port\", processors.Multi(\n    processors.IsRequired(),\n    processors.ToInt64(),\n), env)\n</code></pre> We recommend that you always use a processor to change the type, because there is no guarantee that ApplicationConfigInit will return a value of the type you want.</p>"},{"location":"impl/config/#configuration-examples","title":"Configuration Examples","text":"<p>We recommend always creating an example configuration file when you create an application or component.</p> <p>For example, you created a component and a file with an example configuration of this component.</p> <p>A developer who will use this component will be able to copy and merge the example configuration file into his main application configuration file.</p> <p>After this, this file will be read in function ApplicationConfigInit.</p>"},{"location":"impl/dependency/","title":"Dependency Injection","text":""},{"location":"impl/dependency/#basic-information","title":"Basic Information","text":"<p>Dependency injection is a design pattern used in software engineering to achieve inversion of control between classes and their dependencies. In simpler terms, it's a technique where the dependencies of a class are provided from the outside rather than created within the class itself. This helps to decouple components and promotes easier testing, maintainability, and flexibility in your code.</p> <p>Dependencies can be provided by components and the application. Special methods inside these entities are responsible for this. Let's look at an example:</p> In ApplicationIn Component <pre><code>package application\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        func() SomeService {\n            return &amp;someService{}\n        },\n        // ...\n    }, nil\n}\n\nvar (\n    _ componego.Application             = (*Application)(nil)\n    _ componego.ApplicationDependencies = (*Application)(nil)\n)\n</code></pre> <pre><code>package component\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Component struct {\n}\n\n// ...\n\nfunc (c *Component) ComponentDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        func() SomeService {\n            return &amp;someService{}\n        },\n        // ...\n    }, nil\n}\n\nvar (\n    _ componego.Component             = (*Component)(nil)\n    _ componego.ComponentDependencies = (*Component)(nil)\n)\n</code></pre> <p>Now you can use this provided object in your application.</p> <p>It is recommended to use constructors to create dependencies. Consider these constructors further on this page.</p>"},{"location":"impl/dependency/#dependency-constructors","title":"Dependency Constructors","text":"<p>Let's look at the following code example and possible variations of what the constructor might look like:     <pre><code>func (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        NewProductRepository,\n        // ...\n    }, nil\n}\n\n// ...\n</code></pre></p> <ol> <li>The constructor returns a struct as a pointer:         <pre><code>func NewProductRepository() *ProductRepository {\n    return &amp;ProductRepository{}\n}\n</code></pre></li> <li>The constructor returns a struct as an interface:         <pre><code>func NewProductRepository() ProductRepository {\n    return &amp;productRepository{}\n}\n</code></pre></li> <li>The constructor can return an error as the latest value:        <pre><code>func NewProductRepository() (ProductRepository, error) {\n    return &amp;productRepository{}, nil\n}\n</code></pre></li> <li>The constructor can accept an unlimited number of dependencies:        <pre><code>func NewProductRepository(db * database.Provider) ProductRepository {\n    return &amp;productRepository{\n        db: db,\n    }\n}\n</code></pre></li> <li>You can even do things like this:        <pre><code>func NewProductRepository(di componego.DependencyInvoker) (ProductRepository, error) {\n    repo := &amp;productRepository{}\n    return repo, di.PopulateFields(repo)\n}\n</code></pre></li> </ol> <p>Note</p> <p>Constructors can accept and return an unlimited number of dependencies. However, they must be presented as pointers.</p> <p>It is also recommended to use interfaces, as it can be convenient in some cases.</p> <p>The constructor, like any framework entity, is thread-safe.</p> <p>Another alternative is to represent the dependency directly as an object:     <pre><code>func (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        &amp;ProductRepository{},\n        // ...\n    }, nil\n}\n\n// ...\n</code></pre> Most likely you will rarely use this method.</p> <p>Note</p> <p>Loops between dependencies are not allowed. You will receive an error message when starting the application if a loop occurs.</p> <p>Note</p> <p>If the provided object implements the io.Closer interface, then the Close() function will be called when the application stops.</p>"},{"location":"impl/dependency/#access-to-dependencies","title":"Access to Dependencies","text":"<p>Dependencies can be obtained in several ways. The easiest way is to use the environment.</p>"},{"location":"impl/dependency/#invoke","title":"Invoke","text":"<p>This is a method that takes a function as an argument, which can take any dependencies provided in the components or application.     <pre><code>_, err := env.DependencyInvoker().Invoke(func(service SomeService, repository SomeRepository) {\n    // ...\n})\n</code></pre> The function may also return an error as the last return value:     <pre><code>_, err := env.DependencyInvoker().Invoke(func(service SomeService) error {\n    // ...\n    return service.Action()\n})\n</code></pre> The called function can return a value:     <pre><code>returnValue, err := env.DependencyInvoker().Invoke(func(service SomeService) int {\n    // ...\n    return service.Action()\n})\n// or\nreturnValue, err := env.DependencyInvoker().Invoke(func(service SomeService) (int, error) {\n    // ...\n    return service.Action()\n})\n</code></pre></p> <p>Note</p> <p>Since the return type is type any, you can use a helper to get the correct type: <pre><code>package example\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/dependency\"\n)\n\nfunc GetValue(env componego.Environment) (int, error) {\n    intValue, err := dependency.Invoke[int](SomeFunction, env)\n    // intValue := dependency.InvokeOrPanic[int](SomeFunction, env)\n    return intValue, err\n}\n</code></pre></p> <p>You can also get an object for dependency injection inside a function:     <pre><code>_, err := di.Invoke(func(di componego.DependencyInvoker, service SomeService) (any, error) {\n    // ...\n    return di.Invoke(service.Action)\n})\n</code></pre> Although in this case, you could use closures.</p>"},{"location":"impl/dependency/#populate","title":"Populate","text":"<p>This is a function that fills a variable, which is a pointer.     <pre><code>var service *Service\nerr := env.DependencyInvoker().Populate(&amp;service)\n</code></pre></p> <p>Note</p> <p>The type of the variable must exactly match the requested type.</p> <p>Also, note the pointer and pointer dereferences in the example above. It is expected that *Service type has been provided for dependencies.</p> <p>The difference between functions Populate and Invoke is that the first function can only accept a struct because only a struct can be a pointer. At the same time, the second function can accept arguments of any type included in the list of allowed types for dependencies.</p>"},{"location":"impl/dependency/#populatefields","title":"PopulateFields","text":"<p>The Populate method fills only a variable, but much more often you need to fill fields in a struct. Let's look at an example:     <pre><code>type Service struct {\n    dbProvider database.Provider `componego:\"inject\"`\n}\n\n// ...\n\nservice := &amp;Service{}\nerr := env.DependencyInvoker().PopulateFields(service)\n</code></pre> This method fills only those fields that have the special tag shown in the example. All other fields are ignored. Fields can be private or public. The field type can be any.</p> <p>If an error occurs, the method will return it.</p>"},{"location":"impl/dependency/#default-dependencies","title":"Default Dependencies","text":"<p>Each application has a set of standard dependencies with which you can access various functions of the application.</p> <p>The table shows a set of these dependencies:</p> Variable Description env componego.Environment access to the environment app componego.Application returns the current application appIO componego.ApplicationIO access to the application IO di componego.DependencyInvoker returns the dependency invoker config componego.ConfigProvider provides access to configuration <p>These are objects that are returned by the environment using its methods.</p> <p>Note</p> <p>Although you can get context through the environment, you cannot get context through dependencies. Use the environment directly to obtain the application context.</p> <p>Note</p> <p>Standard dependencies cannot be rewritten. You must use the driver options if you want to change them.</p>"},{"location":"impl/dependency/#rewriting-dependencies","title":"Rewriting Dependencies","text":"<p>Rewriting is one of the main features of the framework. Let's see how you can rewrite dependencies.     <pre><code>func (a *Application) ApplicationDependencies() ([]componego.Dependency, error) {\n    return []componego.Dependency{\n        func() SomeService {\n            return &amp;someService{}\n        },\n        func() SomeService {\n            return &amp;someService2{}\n        },\n        // ...\n    }, nil\n}\n\n// ...\n</code></pre> In this case, the second service will be used because it is specified after the constructor of the first service.</p> <p>For rewriting to work, the return value types must match.  This is the only condition. Constructors can accept any dependency, but the return types must match. Only in this case rewriting will work.</p> <p>If you try to return the type that was returned in the constructors above, but the returned type does not match, you will receive an error.</p> <p>Note</p> <p>The only exception is the last type returned if that type is an error.</p> <p>Rewriting dependencies is one of the key elements in creating mocks using this framework.</p> <p>Remember that according to the documentation about the order of initialization of elements of the framework, method ApplicationDependencies is called after the same function for components (ComponentDependencies).</p> <p>This means that you can rewrite dependencies in your application that were declared in components. You can also rewrite dependencies in components that were added in parent components.</p>"},{"location":"impl/driver/","title":"Application Driver","text":""},{"location":"impl/driver/#basic-information","title":"Basic information","text":"<p>The application driver plays a pivotal role in the Componego runtime by serving as the entry point that initializes and orchestrates all essential functions within an application. Essentially, it acts as the engine that kick-starts the execution of an application by coordinating various components, managing configurations, and initiating critical processes. This driver ensures a smooth and controlled start for the application, setting the stage for seamless operation.</p>"},{"location":"impl/driver/#differences-between-runner","title":"Differences between Runner","text":"<p>The difference is minimal, but the driver can be common for many applications, and it initiates the basic functions of the application by the options (configuration) of the driver. Driver options are what control application (environment factory, dependency manager, event manager, configuration manager, input reader, output writer, error output writer). And yes, you can change them, because they are all just options.</p> <p>In most cases you don't need to know about driver options, but if you want to change some part of the core of the framework, then open the source code to see how it is implemented.</p>"},{"location":"impl/driver/#application-initialization-order","title":"Application initialization order","text":"Componego Flow <p>Note</p> <p>Red elements on image can handle errors that occurred in previous (or nested) functions.</p> <p>Note</p> <p>We recommend looking at this diagram again when you fully understand how to create application and components, and the entities they provide.</p> <p>The general order of calling functions is as follows:</p> <ol> <li>runner.Run</li> <li>driver.RunApplication</li> <li>application.ApplicationConfigInit</li> <li>application.ApplicationComponents</li> <li>component.ComponentComponents (+ getting components for each component)</li> <li>component.ComponentDependencies (for each of the active components)</li> <li>application.ApplicationDependencies</li> <li>component.ComponentInit (for each of the active components)</li> <li>application.ApplicationAction</li> <li>component.ComponentStop (for each of the active components in reverse order)</li> <li>application.ApplicationErrorHandler (If there was an error)</li> <li>exit</li> </ol> <p>Of course, not all methods that are called are described here (if the application or component has these methods). But this list is enough to have a brief overview of the application initialization order.</p> <p>Note</p> <p>The order of initialization and method calls is important in rewriting application elements. For example, an application  can rewrite dependencies of component because a method that returns dependencies for an application object (ApplicationDependencies) is called after the same function for components (ComponentDependencies).</p> <p>We talk about rewriting elements further on the pages. This can be useful when creating mocks.</p>"},{"location":"impl/environment/","title":"Application Environment","text":""},{"location":"impl/environment/#basic-information","title":"Basic information","text":"<p>An environment package serves as a comprehensive solution for managing the runtime of application environment. This package not only provides access to dependency injection (DI) management but also includes features for handling application active components, provides access to configuration, application mode, IO and global context.</p>"},{"location":"impl/environment/#how-to-get-environment","title":"How to get environment","text":"<p>The environment can be accessed in several ways. The first and easiest way is to get this object in the application action.     <pre><code>func (a *Application) ApplicationAction(env componego.Environment, _ []string) (int, error) {\n    env.GetContext()\n    env.Application()\n    env.ApplicationIO()\n    env.ApplicationMode()\n    env.Components()\n    env.DependencyInvoker()\n    env.ConfigProvider()\n\n    // ...\n    return componego.SuccessExitCode, nil\n}\n\nvar _ componego.Application = (*Application)(nil)\n</code></pre></p> <p>You can also get this object via DI.     <pre><code>type MyType struct {\n    env componego.Environment `componego:\"inject\"`\n}\n\nfunc (m *MyType) Method() {\n    if m.env.ApplicationMode() == componego.DeveloperMode {\n        // ...\n    }\n}\n</code></pre> or     <pre><code>err := dependencyInvoker.Invoke(func(env componego.Environment) {\n    // ...\n})\n</code></pre></p> <p>or another ways described in the documentation about DI.</p> <p>Note</p> <p>The environment object cannot be rewritten by rewritten DI objects. This object is present in any application.</p>"},{"location":"impl/environment/#how-to-use-environment","title":"How to use environment","text":"Method Description Documentation env.GetContext() returns a current application context open env.SetContext(newCtx) sets a new application context open env.Application() returns a current application object open env.ApplicationIO() returns an object for getting application input and output open env.ApplicationMode() returns the mode in which the application is started open env.Components() returns a sorted list of active application components open env.DependencyInvoker() returns an object to invoke dependencies open env.ConfigProvider() returns an object for getting config open <p>This is a universal key for accessing any part of the application.</p>"},{"location":"impl/environment/#application-context","title":"Application Context","text":"<p>It is recommended to use the application context to run various functions. You can also replace the current context with another context, but the new context must inherit from the previous main context:     <pre><code>package component\n\nimport (\n    \"context\"\n    \"time\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/component\"\n)\n\nfunc NewComponent() componego.Component {\n    factory := component.NewFactory(\"example\", \"0.0.1\")\n    factory.SetComponentInit(func(env componego.Environment) error {\n        ctx, cancelCtx := context.WithTimeout(env.GetContext(), time.Second*100)\n        // ...\n        return env.SetContext(ctx)\n    })\n    return factory.Build()\n}\n</code></pre></p>"},{"location":"impl/environment/#application-io","title":"Application IO","text":"<p>If you want to output (or receive) some text to (from) the console, then you must use special methods:     <pre><code>func (a *Application) ApplicationAction(env componego.Environment, _ []string) (int, error) {\n    appIO := env.ApplicationIO()\n    _, _ = fmt.Fprintln(appIO.OutputWriter(), \"your text\")\n    _, _ = fmt.Fprintln(appIO.ErrorOutputWriter(), \"your error text\")\n    reader := bufio.NewReader(appIO.InputReader())\n    text, _ := reader.ReadString('\\n')\n}\n</code></pre></p>"},{"location":"impl/processor/","title":"Processors","text":""},{"location":"impl/processor/#basic-information","title":"Basic information","text":"<p>Processors are special functions that convert variables of one type into another and validate them.</p> <p>On the previous page you would see an example of using processors:     <pre><code>package config\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/environment/managers/config\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc GetConnectionName(env componego.Environment) string {\n    return config.GetOrPanic[string](\n        \"connection.name\",\n        processors.IsRequired(),\n        env,\n    )\n}\n</code></pre></p>"},{"location":"impl/processor/#default-processors","title":"Default Processors","text":"Function Description processors.ToBool() converts the value to boolean processors.IsBool() checks whether a value is a boolean value processors.ToInt64() converts the value to int64 processors.ToFloat64() converts the value to float64 processors.ToString() converts the value to string processors.IsRequired() checks that the value is present (not nil) processors.DefaultValue(anyValue) sets the default value if the previous value is nil"},{"location":"impl/processor/#custom-processor","title":"Custom Processor","text":"<p>There are 2 simple ways to create this:</p> Long codeShort code <pre><code>package processor\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Processor struct{}\n\nfunc (p *Processor) ProcessData(value any) (any, error) {\n    // convert a value to another or validate a value\n    // if there is an error, then you must return it\n    return newValue, nil\n}\n\nvar _ componego.Processor = (*Processor)(nil)\n</code></pre> <pre><code> package processor\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc NewProcessor() componego.Processor {\n    return processors.New(func(value any) (any, error) {\n        // convert a value to another or validate a value\n        // if there is an error, then we must return it\n        return newValue, nil\n    })\n}\n</code></pre> Does it support DI? <p>Of course, like other parts of the application, you can use dependencies: <pre><code>package processor\n\nimport (\n    \"github.com/componego/componego\"\n)\n\ntype Processor struct {\n    env componego.Environment `componego:\"inject\"`\n}\n\n// ...\n</code></pre></p>"},{"location":"impl/processor/#multi-processor","title":"Multi Processor","text":"<p>This can be implemented using processors.Multi:     <pre><code>package processor\n\nimport (\n    \"strings\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc NewProcessor() componego.Processor {\n    return processors.Multi(\n        processors.ToString(),\n        processors.New(func(value any) (any, error) {\n            return strings.Split(value.(string), \",\"), nil\n        }),\n    )\n}\n</code></pre> In the second processor in the example above, we are not checking if the value is a string as we are confident that it is a string because the value will be converted to a string in the first processor.</p> <p>This is a chain of function calls one after another. If an error occurs in any function, the chain will be interrupted.</p>"},{"location":"impl/processor/#processor-as-validator","title":"Processor As Validator","text":"<p>In fact, you can use processors not only to convert data to another format, but also for validation.     <pre><code>package processor\n\nimport (\n    \"fmt\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/processors\"\n)\n\nfunc ToAge() componego.Processor {\n    return processors.Multi(\n        processors.ToInt64(),\n        processors.New(func(value any) (any, error) {\n            age := value.(int64)\n            if age &lt; 21 {\n                return nil, fmt.Errorf(\"invalid age: %d\", age)\n            }\n            return age, nil\n        }),\n    )\n}\n</code></pre> You can also use third-party libraries to validate specific rules.     <pre><code>package processor\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/processors\"\n    \"github.com/go-playground/validator/v10\" // third-party library\n)\n\nvar validate = validator.New()\n\nfunc ToAge() componego.Processor {\n    return processors.Multi(\n        processors.ToInt64(),\n        processors.New(func(value any) (any, error) {\n            return value, validate.Var(value, \"required,numeric,min=21\")\n        }),\n    )\n}\n</code></pre></p> <p>Note</p> <p>You can create a separate file where you can register all the possible processors that you are going to use in your application.</p> <p>Note</p> <p>The framework was designed as a way to run an application. You should not use framework functions in the main loop of your application. Use the framework only to initialize the main application loop.</p>"},{"location":"impl/runner/","title":"Application Runner","text":""},{"location":"impl/runner/#basic-information","title":"Basic Information","text":"<p>This is the entity that runs the application using the driver.     <pre><code>package main\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/runner\"\n\n    \"github.com/componego/componego/examples/hello-app/internal/application\"\n)\n\nfunc main() {\n    runner.RunAndExit(application.New(), componego.ProductionMode)\n}\n</code></pre> This line in the main function is enough to start your application.</p> <p>Function runner.RunAndExit starts the application and after stopping the application exits the program with exit code.</p> <p>Note</p> <p>If the application completed with an error, then the exit code from the application will not be equal to 0 (componego.SuccessExitCode).</p> <p>You can also use runner.Run, which starts the application but does not exit it:     <pre><code>package main\n\nimport (\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/runner\"\n\n    \"github.com/componego/componego/examples/hello-app/internal/application\"\n)\n\nfunc main() {\n    exitCode := runner.Run(application.New(), componego.ProductionMode)\n    // ...\n}\n</code></pre></p> <p>There are also methods RunWithContext and RunGracefullyAndExit, which allow you to run the application using a custom context or with a graceful shutdown.</p>"},{"location":"impl/runner/#application-mode","title":"Application Mode","text":"<p>As you can see, you can run the application in different modes.</p> <p>By default, there are several modes:</p> Name Description componego.ProductionMode for production environment componego.DeveloperMode for developers componego.TestMode for application tests <p>But you can add any mode you want.</p> <p>You can get the application mode through the environment.     <pre><code>if env.ApplicationMode() == componego.DeveloperMode {\n    // ...\n}\n</code></pre></p> <p>Note</p> <p>You should always use production mode when you run your application on a production server. It is also recommended to use test mode when you run the application in tests.</p> <p>Note</p> <p>We strongly recommend using multiple application entry points, as shown in this example.</p> <p>We believe that applications should know in what mode it will be launched even before launching. For example, this allows you to read different configurations depending on the environment, instead of building the environment depending on the configuration.</p>"},{"location":"impl/runner/#custom-runner","title":"Custom Runner","text":"<p>The custom runner is significant because it is where you can start modifying the framework core to suit your specific requirements.</p> <p>Note</p> <p>If you are new to our framework, please skip this section. Come back to it after you've fully read the rest of the documentation pages.</p>"},{"location":"impl/runner/#specific-driver-options","title":"Specific Driver Options","text":"<p>This is related to the application driver, but you can control it through the runner. Options are some factories that implement all the entities that the framework provides. So this is the key (but not the only one) how you can replace the core of the framework with your code.</p> <p>For example, you can pass additional options to your application. Let's create a new Run function that takes arguments.     <pre><code>package custom_runner\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    \"github.com/componego/componego\"\n    \"github.com/componego/componego/impl/driver\"\n    \"github.com/componego/componego/impl/runner/unhandled-errors\"\n)\n\nfunc Run(app componego.Application, appMode componego.ApplicationMode, additionalOptions any) int {\n    d := driver.New(&amp;driver.Options{\n        Additional: additionalOptions,\n        // ... other options\n    })\n    exitCode, err := d.RunApplication(context.Background(), app, appMode)\n    if err != nil {\n        _, _ = fmt.Fprint(os.Stderr, unhandled_errors.ToString(err, appMode, unhandled_errors.GetHandlers()))\n    }\n    return exitCode\n}\n</code></pre></p> <p>Look at what options are available in the code driver to ensure you can control everything.</p> <p>Note</p> <p>We are creating a context in this code. You can read about how to use this context here.</p> <p>Note</p> <p>The ability to replace the core of the framework is important because you are not tied to the implementation of some functions of the framework. You can replace them with other methods that satisfy some interfaces.</p> <p>However, more important is the ability to easily replace business logic, because this can be used in mocks and more. The framework can do this too. We have described this on other pages.</p>"},{"location":"impl/runner/#errors-handing","title":"Errors Handing","text":"<p>Note</p> <p>It is recommended to use a special application] method ApplicationErrorHandler to catch global errors or panic.</p> <p>At the runner level you can handle errors that were not handled at all previous levels.</p> <p>Based on the previous example, the following lines add error handling.     <pre><code>func Run(app componego.Application, appMode componego.ApplicationMode) int {\n    d := driver.New(nil)\n    exitCode, err := d.RunApplication(context.Background(), app, appMode)\n    if err != nil {\n        handlers := unhandled_errors.GetHandlers()\n        _, _ = fmt.Fprint(os.Stderr, unhandled_errors.ToString(err, appMode, handlers))\n    }\n    return exitCode\n}\n</code></pre> We convert the error into a string using some handlers and show it to the user. Of course, you can use any error handling you want or add your handlers to the standard handlers.     <pre><code>handlers := unhandled_errors.GetHandlers()\nhandlers.AddBefore(\n    \"company:my-handler-name\",\n    func(err error, writer io.Writer, appMode componego.ApplicationMode) bool {\n        if errors.Is(err, MyError) {\n            // ...\n            return true // return true if the error is processed\n        }\n        return false\n    },\n    \"componego:vendor-proxy\",\n)\n_, _ = fmt.Fprint(os.Stderr, unhandled_errors.ToString(err, appMode, handlers))\n</code></pre></p> <p>In addition to function AddBefore, there are many other functions for handling errors in the required sequence (ordered map). Look at the source code for a complete list of these methods.</p> <p>Note</p> <p>Don't be afraid to look into the core of the framework and copy methods to make changes for your specific requirements. However, try to follow the rewriting rules provided by the framework.</p>"},{"location":"tests/mock/","title":"Application Mock","text":""},{"location":"tests/mock/#basic-example","title":"Basic Example","text":"<p>Let's say you want to replace some part of your application for testing. This is very easy to do and is one of the main features of this framework.</p> <p>Let's use an example application to look at how you can create a mock.     <pre><code>package mocks\n\nimport (\n    \"github.com/componego/componego\"\n\n    \"secret.com/project-x/internal/application\"\n)\n\ntype ApplicationMock struct {\n    *application.Application\n}\n\nfunc NewApplicationMock() *ApplicationMock {\n    return &amp;ApplicationMock{\n        Application: application.New(),\n    }\n}\n\n// ... other methods\n\nvar (\n    _ componego.Application = (*ApplicationMock)(nil)\n    // ...\n)\n</code></pre> As you can see, we use inheritance. In a child (mock) struct, you can rewrite methods and return new values.</p> <p>Here's an example of what it might look like for dependencies, but you can add any other method.     <pre><code>func (a *ApplicationMock) ApplicationDependencies() ([]componego.Dependency, error) {\n    dependencies, err := a.Application.ApplicationDependencies()\n    dependencies = append(\n        dependencies,\n        func() Service {\n            return &amp;mockService{}\n        },\n        // ...\n        )\n    return dependencies, err\n}\n</code></pre> We call the parent method and add new data.</p> <p>How to run the mock is shown on the next documentation page.</p>"},{"location":"tests/mock/#rewriting-rules","title":"Rewriting Rules","text":"<p>We have already described this on previous documentation pages for each framework entity. But let's sum it up.</p> <p>Note</p> <p>We use the order in which the methods are called. Methods that were called last may rewrite the return data of previous methods.</p>"},{"location":"tests/mock/#for-components","title":"For Components","text":"<p>If several components have the same identifier, the component specified last will be applied.</p>"},{"location":"tests/mock/#for-dependencies","title":"For Dependencies","text":"<p>The last dependencies in the list are applied.</p> <p>If you use a constructor for dependencies, the dependencies will be rewritten by the last constructor if the return types match the constructor you want to rewrite.</p> <p>You will get an error if you return a constructor that returns a different set of types. The exception is the last returned type if it is an error.</p> <p>If instead of a constructor you use an object directly, then you can rewrite this value with the same object or constructor that returns the same object type.</p> <p>Note</p> <p>Objects that are returned by environment methods cannot be rewritten.</p>"},{"location":"tests/mock/#for-configuration","title":"For Configuration","text":"<p>Everything is simple here. You need to read data from another resource.</p> <p>For example, you can use application mode to read different configurations:     <pre><code>package application\n\nimport (\n    \"fmt\"\n\n    \"github.com/componego/componego\"\n    // ...\n)\n\ntype Application struct {\n}\n\n// ...\n\nfunc (a *Application) ApplicationConfigInit(appMode componego.ApplicationMode, options any) (map[string]any, error) {\n    switch appMode {\n    case componego.ProductionMode:\n        return config_reader.Read(\"./config/production.config.json\")\n    case componego.DeveloperMode:\n        return config_reader.Read(\"./config/developer.config.json\")\n    case componego.TestMode:\n        return config_reader.Read(\"./config/test.config.json\")\n    default:\n        return nil, fmt.Errorf(\"not supported application mode: %d\", appMode)\n    }\n}\n\nvar (\n    _ componego.Application           = (*Application)(nil)\n    _ componego.ApplicationConfigInit = (*Application)(nil)\n)\n</code></pre></p> <p>You can also rewrite this method in a mock and return a map with a different configuration that is needed for your test.</p>"},{"location":"tests/mock/#for-framework-core","title":"For Framework Core","text":"<p>If you want to replace something inside the framework, then you can use driver options.</p> <p>Don't be afraid to copy core functions to make the changes necessary for your project. We will also be glad to receive any suggestion or pull request that will help develop and improve this project.</p>"},{"location":"tests/runner/","title":"Tests Runner","text":""},{"location":"tests/runner/#basic-example","title":"Basic Example","text":"<p>The simplest way is this:     <pre><code>package tests\n\nimport (\n    \"testing\"\n\n    \"github.com/componego/componego/tests/runner\"\n\n    \"secret.com/project-x/tests/mocks\"\n)\n\nfunc TestExample(t *testing.T) {\n    env, cancelEnv := runner.CreateTestEnvironment(t, mocks.NewApplicationMock(), nil)\n    t.Cleanup(cancelEnv)\n    // ... here you can use application environment.\n}\n</code></pre> In this example, we created a new environment based on the application mock. You can use this environment to run the necessary functions in your tests.</p> <p>The last argument of the function accepts the driver options that will be applied to the current test.</p> <p>When the environment is canceled, all necessary functions will be called to stop the application.</p> <p>The framework is thread safe so you can run tests in parallel. However, your personal code or the code of third-party libraries you use may not be thread safe.</p> <p>Note</p> <p>The example above showed how to test an application.</p> <p>To test component, you must create an application that depends only on that component. This way you can, for example, configure a component, because this method is in the application.</p>"},{"location":"tests/runner/#test-mode","title":"Test Mode","text":"<p>In tests, the application should be launched in mode componego.TestMode. There are different application launch modes. However, for tests, it is recommended to use mode componego.TestMode.</p> <p>The above code runs the application in this mode. Take this subtlety into account in your code.</p>"},{"location":"warnings/goroutine-leak/","title":"Goroutine leak when exiting the application","text":"<p>Only in development mode, you may see warnings when exiting the application that some goroutines are still running.</p> <p>This means that in addition to the main goroutine, other goroutines are also running. In any case, all goroutines will be terminated after exiting the application. However, some goroutines may be doing important work that will be terminated forcefully and possibly unsuccessfully.</p> <p>Of course, you cannot guarantee 100% that all goroutines will be completed, but you should strive for this.</p> <p>Some packages run goroutines that constantly monitor events.</p> <p>Here is an example code and how you can detect a goroutine leak.     <pre><code>package main\n\nimport (\n    \"os\"\n    \"os/signal\"\n    \"runtime/pprof\"\n    \"syscall\"\n)\n\nfunc main() {\n    interruptChan := make(chan os.Signal, 1)\n    signal.Notify(interruptChan, os.Interrupt, syscall.SIGTERM)\n    // ...\n    signal.Stop(interruptChan)\n    // ...\n    _ = pprof.Lookup(\"goroutine\").WriteTo(os.Stdout, 1)\n}\n</code></pre> The output of this program will be approximately the following:</p> <p></p> <p>As you can see, we still have a goroutine that monitors signals. This goroutine is safe, but there may be other goroutines.</p> <p>Please ignore this warning if there are no unwanted goroutine leak.</p>"}]}